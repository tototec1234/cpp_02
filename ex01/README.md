# Fixed Point Number Class (ex01)

## 概要
8ビットの小数部を持つ固定小数点数クラスの実装です。

## Fixedクラスの設計

### 内部表現
- **データ型**: `int` (32ビット)
- **小数ビット数**: 8ビット (`_fractionalBits = 8`)
- **構成**: 24ビット整数部 + 8ビット小数部

### 格納可能範囲
- **理論的範囲**: INT_MIN ≤ _value ≤ INT_MAX
- **実用的整数範囲**: 
  - 最大値: `INT_MAX / (1 << 8) = 8,388,607`
  - 最小値: `INT_MIN / (1 << 8) = -8,388,608`

## toFloat() 実装の重要な発見

### 実験で判明した問題

#### 問題のコード
```cpp
return (this->_value / (1 << _fractionalBits));  // 整数除算！
```

#### 実験結果
```
入力: Fixed(8192.5f)
内部値: _value = 2,097,280
期待値: 2,097,280 ÷ 256 = 8192.5
実際の出力: 8192.0  ← 小数部が失われる！
```

#### 原因分析
1. **`this->_value`**: int型 (2,097,280)
2. **`(1 << _fractionalBits)`**: int型 (256)  
3. **結果**: 整数除算が実行される → `2,097,280 / 256 = 8192` (小数部切り捨て)

### 正しい実装

#### 必須の型キャスト
```cpp
return (static_cast<float>(this->_value) / (1 << _fractionalBits));
```

#### なぜキャストが必要なのか

**当初の分析は不完全でした。** 実験により以下が判明：

1. **分母（256）の精度は問題なし**
   - 256はfloatで完全に正確に表現可能
   - 2の冪乗なので精度損失なし

2. **真の問題は整数除算**
   - C++では `int / int` は整数除算
   - 小数部が完全に切り捨てられる
   - これは精度の問題ではなく、**演算の種類の問題**

#### 実証実験
```cpp
// テストケース
Fixed n = Fixed(8192.5f);

// 内部処理
8192.5f * 256 = 2,097,280  // 正しく格納
int_value = 2,097,280      // 内部値は正確

// toFloat()での除算
2,097,280 / 256 = 8192     // 整数除算 → 小数部消失
static_cast<float>(2,097,280) / 256 = 8192.5  // 浮動小数点除算 → 正確
```

### IEEE 754 float精度限界の再評価

元の分析は理論的には正しいものの、**この特定のケースでは分母が256という小さな値のため、精度問題は発生しない**ことが実験で確認されました。

#### 精度問題が発生する条件
- 除算結果がfloatの24ビット精度を超える場合
- 現在の設計（256で除算）では、この条件に到達しない

### オーバーフロー検出の実装

#### 2段階チェック体系
```cpp
// 1. INT_MAX/MIN チェック（赤色警告）
if (scaled_value > static_cast<float>(INT_MAX)) { /* オーバーフロー */ }

// 2. 精度安全範囲チェック（マゼンタ警告）
const float SAFE_MAX_FLOAT = 65536.0f;  // 2^16
if (floatingPointNumber > SAFE_MAX_FLOAT) { /* 精度警告 */ }
```

#### 実験結果による境界値
```
整数コンストラクタ:
- 安全範囲: -8,388,608 ≤ n ≤ 8,388,607
- オーバーフロー例: Fixed(8388608) → 警告表示

フロートコンストラクタ:
- INT_MAX制限: 約±8,388,607.996
- 精度安全制限: ±65,536（桁落ち防止）
```

## 学習成果

### 1. 理論と実装の乖離
- 理論的分析だけでは不十分
- 実際の実装テストが重要

### 2. C++の型システム理解
- 整数除算 vs 浮動小数点除算の違い
- 暗黙の型変換のタイミング

### 3. デバッグ技術
- 段階的な値の確認
- 期待値と実際値の比較

### オーバーフロー検出
整数コンストラクタでは以下の範囲チェックを実装：
```cpp
const int MAX_SAFE_INT = INT_MAX / (1 << _fractionalBits);
const int MIN_SAFE_INT = INT_MIN / (1 << _fractionalBits);
```

範囲外の値が入力された場合、警告メッセージを出力します。

## 使用例
```cpp
Fixed a(1.5f);        // フロートコンストラクタ
Fixed b(42);          // 整数コンストラクタ
Fixed c(8388608);     // オーバーフロー警告が出力される
Fixed d(8192.5f);     // 小数部のテスト

std::cout << a << std::endl;  // 1.5
std::cout << b.toInt() << std::endl;  // 42
std::cout << d << std::endl;  // 8192.5（正しい実装の場合）
```

## 学習ポイント
1. 固定小数点数の内部表現理解
2. **整数除算 vs 浮動小数点除算の重要な違い**
3. **実装テストによる理論検証の必要性**
4. ビット演算による効率的な実装
5. オーバーフロー検出とエラーハンドリング
6. マジックナンバーを避けた保守性の高いコード設計
7. **デバッグ技術と段階的問題解決**
